"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Startup = void 0;
const inversify_1 = require("inversify");
const dependency_injection_types_1 = require("../proxy/dependency.injection.types");
let Startup = class Startup {
    constructor(upstreamProxyConfigurator, proxyMain, cypressFacade, environment, externalNtlmProxyFacade, debug) {
        this._internalNtlmProxy = true;
        this._upstreamProxyConfigurator = upstreamProxyConfigurator;
        this._proxyMain = proxyMain;
        this._cypressFacade = cypressFacade;
        this._environment = environment;
        this._externalNtlmProxyFacade = externalNtlmProxyFacade;
        this._debug = debug;
    }
    checkCypressIsInstalled() {
        if (this._cypressFacade.cypressLoaded() === false) {
            throw new Error("cypress-ntlm-auth requires Cypress to be installed.");
        }
    }
    getArgsAfterCypressNtlm(args) {
        const cypressNtlmIndex = args.findIndex((t) => t === "cypress-ntlm" ||
            t === "cypress.ntlm.js" ||
            t.endsWith("/cypress-ntlm") ||
            t.endsWith("/cypress.ntlm.js") ||
            t.endsWith("\\cypress-ntlm") ||
            t.endsWith("\\cypress.ntlm.js"));
        if (cypressNtlmIndex === -1) {
            this._debug.log(args);
            throw new Error("Cannot parse command line arguments");
        }
        return args.slice(cypressNtlmIndex + 1);
    }
    argumentsToCypressMode(args) {
        const cliArguments = this.getArgsAfterCypressNtlm(args);
        if (cliArguments.length > 0 &&
            (cliArguments[0] === "run" || cliArguments[0] === "open")) {
            return cliArguments[0];
        }
        throw new Error("Unsupported command, use cypress-ntlm open or cypress-ntlm run.");
    }
    prepareOptions(args) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkCypressIsInstalled();
            let cliArguments = this.getArgsAfterCypressNtlm(args);
            cliArguments = cliArguments.slice(1);
            cliArguments.unshift("run");
            cliArguments.unshift("cypress");
            return yield this._cypressFacade.parseRunArguments(cliArguments);
        });
    }
    prepareProxy() {
        return __awaiter(this, void 0, void 0, function* () {
            let ports;
            if (this._environment.configApiUrl) {
                ports = yield this.prepareExternalNtlmProxy();
            }
            else {
                ports = yield this.startNtlmProxy();
            }
            this._environment.configureForCypress(ports);
            this._upstreamProxyConfigurator.removeUnusedProxyEnv();
        });
    }
    prepareExternalNtlmProxy() {
        return __awaiter(this, void 0, void 0, function* () {
            this._internalNtlmProxy = false;
            this._upstreamProxyConfigurator.processNoProxyLoopback();
            this._debug.log("Detected CYPRESS_NTLM_AUTH_API environment variable, using existing ntlm-proxy");
            return yield this._externalNtlmProxyFacade.alive(this._environment.configApiUrl);
        });
    }
    startNtlmProxy() {
        return __awaiter(this, void 0, void 0, function* () {
            this._internalNtlmProxy = true;
            this._upstreamProxyConfigurator.processNoProxyLoopback();
            this._debug.log("Starting ntlm-proxy...");
            return yield this._proxyMain.run(this._environment.httpProxy, this._environment.httpsProxy, this._environment.noProxy);
        });
    }
    run(options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkCypressIsInstalled();
            yield this.prepareProxy();
            this._debug.log("Running tests through Cypress...");
            // Start up Cypress and let it parse any options
            try {
                const result = yield this._cypressFacade.run(options);
                this._debug.log("Tests finished");
                this._debug.log(result);
                return result;
            }
            catch (err) {
                this._debug.log("Tests exception");
                throw err;
            }
            finally {
                yield this.stopNtlmProxy();
            }
        });
    }
    open(options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkCypressIsInstalled();
            yield this.prepareProxy();
            this._debug.log("Opening Cypress...");
            try {
                const result = yield this._cypressFacade.open(options);
                this._debug.log("Cypress closed");
                this._debug.log(result);
                return result;
            }
            catch (err) {
                this._debug.log("Tests exception");
                throw err;
            }
            finally {
                yield this.stopNtlmProxy();
            }
        });
    }
    stopNtlmProxy() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._internalNtlmProxy) {
                this._debug.log("Stopping ntlm-proxy...");
                yield this._proxyMain.stop();
            }
        });
    }
};
Startup = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(dependency_injection_types_1.TYPES.IUpstreamProxyConfigurator)),
    __param(1, inversify_1.inject(dependency_injection_types_1.TYPES.IMain)),
    __param(2, inversify_1.inject(dependency_injection_types_1.TYPES.ICypressFacade)),
    __param(3, inversify_1.inject(dependency_injection_types_1.TYPES.IEnvironment)),
    __param(4, inversify_1.inject(dependency_injection_types_1.TYPES.INtlmProxyFacade)),
    __param(5, inversify_1.inject(dependency_injection_types_1.TYPES.IDebugLogger)),
    __metadata("design:paramtypes", [Object, Object, Object, Object, Object, Object])
], Startup);
exports.Startup = Startup;
