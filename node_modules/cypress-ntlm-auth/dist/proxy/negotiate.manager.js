"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NegotiateManager = void 0;
const inversify_1 = require("inversify");
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const dependency_injection_types_1 = require("./dependency.injection.types");
let NegotiateManager = class NegotiateManager {
    constructor(debug) {
        this._debug = debug;
    }
    handshake(ctx, ntlmHostUrl, context, callback) {
        context.setState(ntlmHostUrl, 0 /* NotAuthenticated */);
        let requestToken;
        try {
            requestToken = context.winSso.createAuthRequestHeader();
        }
        catch (err) {
            return callback(err, ctx.serverToProxyResponse);
        }
        this.dropOriginalResponse(ctx);
        const originalRequestOptions = {
            method: ctx.proxyToServerRequestOptions.method,
            path: ctx.proxyToServerRequestOptions.path,
            host: ctx.proxyToServerRequestOptions.host,
            port: ctx.proxyToServerRequestOptions.port,
            agent: ctx.proxyToServerRequestOptions.agent,
            headers: ctx.proxyToServerRequestOptions.headers,
        };
        const requestOptions = Object.assign({}, originalRequestOptions);
        requestOptions.headers = {};
        requestOptions.headers["authorization"] = requestToken;
        requestOptions.headers["connection"] = "keep-alive";
        const proto = ctx.isSSL ? https_1.default : http_1.default;
        const req = proto.request(requestOptions, (res) => this.handshakeResponse(res, ntlmHostUrl, context, originalRequestOptions, ctx.isSSL, callback));
        req.on("error", (err) => {
            this._debug.log("Error while sending Negotiate message token request:", err);
            context.setState(ntlmHostUrl, 0 /* NotAuthenticated */);
            return callback(err);
        });
        this._debug.log("Sending Negotiate message token request");
        this.debugHeader(requestToken, true);
        context.setState(ntlmHostUrl, 1 /* Type1Sent */);
        req.end();
    }
    handshakeResponse(res, ntlmHostUrl, context, originalRequestOptions, isSSL, callback) {
        res.pause();
        if (this.containsNegotiateToken(res) === false) {
            if (this.acceptsNegotiateAuthentication(res) === false) {
                this._debug.log("Negotiate authentication failed (www-authenticate with Negotiate not found in server response) with host", ntlmHostUrl.href);
                context.setState(ntlmHostUrl, 0 /* NotAuthenticated */);
                return callback(new Error("Negotiate authentication failed " +
                    "(www-authenticate with Negotiate not found in server response) with host " +
                    ntlmHostUrl.href), res);
            }
            else if (res.statusCode === 401) {
                this._debug.log("Negotiate authentication failed (invalid credentials) with host", ntlmHostUrl.href);
                context.setState(ntlmHostUrl, 0 /* NotAuthenticated */);
                return callback(undefined, res);
            }
            else {
                this._debug.log("Negotiate authentication failed (server responded without token) with host", ntlmHostUrl.href);
                context.setState(ntlmHostUrl, 0 /* NotAuthenticated */);
                return callback(undefined, res);
            }
        }
        context.setState(ntlmHostUrl, 2 /* Type2Received */);
        let responseToken;
        try {
            responseToken = context.winSso.createAuthResponseHeader(res.headers["www-authenticate"] || "");
        }
        catch (err) {
            context.setState(ntlmHostUrl, 0 /* NotAuthenticated */);
            return callback(err, res);
        }
        if (!responseToken && res.statusCode !== 401) {
            this._debug.log("Negotiate authentication successful with host", ntlmHostUrl.href);
            context.setState(ntlmHostUrl, 4 /* Authenticated */);
            return callback(undefined, res);
        }
        if (!responseToken && res.statusCode === 401) {
            this._debug.log("Negotiate authentication failed (invalid credentials) with host", ntlmHostUrl.href);
            context.setState(ntlmHostUrl, 0 /* NotAuthenticated */);
            return callback(undefined, res);
        }
        // TODO - do we need to handle responseToken && res.statusCode !== 401 ?
        const requestOptions = {
            method: originalRequestOptions.method,
            path: originalRequestOptions.path,
            host: originalRequestOptions.host,
            port: originalRequestOptions.port,
            agent: originalRequestOptions.agent,
            headers: originalRequestOptions.headers,
        };
        if (requestOptions.headers) {
            // Always true, silent the compiler
            requestOptions.headers["authorization"] = responseToken;
        }
        res.on("end", () => {
            const proto = isSSL ? https_1.default : http_1.default;
            const req = proto.request(requestOptions, (res) => this.handshakeResponse(res, ntlmHostUrl, context, originalRequestOptions, isSSL, callback));
            req.on("error", (err) => {
                this._debug.log("Error while sending Negotiate message token response:", err);
                context.setState(ntlmHostUrl, 0 /* NotAuthenticated */);
                return callback(err);
            });
            this._debug.log("Sending Negotiate message token response with initial client request");
            this.debugHeader(responseToken, true);
            context.setState(ntlmHostUrl, 3 /* Type3Sent */);
            req.write(context.getRequestBody());
            req.end();
        });
        res.resume();
    }
    dropOriginalResponse(ctx) {
        ctx.onResponseData((ctx, chunk, callback) => {
            return;
        });
        ctx.onResponseEnd((ctx, callback) => {
            return;
        });
        ctx.serverToProxyResponse.resume();
    }
    acceptsNegotiateAuthentication(res) {
        // Ensure that we're talking Negotiate here
        const wwwAuthenticate = res.headers["www-authenticate"];
        if (wwwAuthenticate &&
            wwwAuthenticate.split(", ").indexOf("Negotiate") !== -1) {
            return true;
        }
        return false;
    }
    containsNegotiateToken(res) {
        const wwwAuthenticate = res.headers["www-authenticate"];
        if (wwwAuthenticate && wwwAuthenticate.startsWith("Negotiate ")) {
            return true;
        }
        return false;
    }
    debugHeader(obj, brackets) {
        if (process.env.DEBUG_NTLM_HEADERS &&
            process.env.DEBUG_NTLM_HEADERS === "1") {
            if (brackets) {
                this._debug.log("[" + obj + "]");
            }
            else {
                this._debug.log(obj);
            }
        }
    }
};
NegotiateManager = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(dependency_injection_types_1.TYPES.IDebugLogger)),
    __metadata("design:paramtypes", [Object])
], NegotiateManager);
exports.NegotiateManager = NegotiateManager;
